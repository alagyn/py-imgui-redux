import re
from typing import TextIO
from config import Config


class ParsedEnum:

    def __init__(self, prefix: str, outputName: str):
        self.prefix = prefix
        self.outputName = outputName
        self.values: list[str] = []

    def generate(self, out: TextIO):
        out.write(f'BindEnum(m, "{self.outputName}")\n')
        for value in self.values:
            if value == "None":
                out.write(f'    .value("None_", {self.prefix}None)\n')
            else:
                out.write(f'    .value("{value}", {self.prefix}{value})\n')
        out.write(";\n")


def parse(
    prefix: str,
    outputName: str,
    lines: list[str],
    idx: int,
) -> tuple[int, ParsedEnum]:

    out = ParsedEnum(prefix, outputName)

    PARSE = re.compile(f'({prefix}_)?' + r"(?P<name>[a-zA-Z_0-9]+)( *=.*)?")

    while lines[idx] != "};":
        m = PARSE.match(lines[idx])
        if m is None:
            raise RuntimeError(
                f'Invalid enum line? {prefix=} line={lines[idx]}'
            )
        valName = m.group("name")
        out.values.append(valName)
        idx += 1

    return idx, out


def writeEnumFile(
    config: Config,
    header: TextIO,
    headerFilename: str,
    filename: str,
    enums: list[ParsedEnum]
):
    header.write(f"void init_{config.prefix}_enums(py::module& m);\n")

    with open(filename, mode='w') as f:
        f.write("// WARNING AUTOGENERATED DO NOT EDIT\n")
        f.write(f'#include "{headerFilename}"\n')
        f.write("#include <binder/enum-utility.h>\n")
        f.write(f"void init_{config.prefix}_enums(py::module& m){{\n")
        for enum in enums:
            enum.generate(f)
        f.write("}\n")
