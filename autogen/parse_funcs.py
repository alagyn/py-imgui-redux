from typing import TextIO
import re
from io import StringIO

from config import Config


class ParsedFunc:

    def __init__(
        self, name: str, args: list[tuple[str, str, str | None]]
    ) -> None:
        self.name = name
        self.args = args

    def generate(self, config: Config, f: TextIO):
        f.write(f'm.def("{self.name}", ')

        if len(self.args) > 0:
            typeStr = ",".join([x[0] for x in self.args])
            f.write(
                f'py::overload_cast<{typeStr}>({config.namespace}::{self.name}), '
            )
        else:
            f.write(f'py::overload_cast<>({config.namespace}::{self.name}), ')

        for arg in self.args:
            f.write(f'"{arg[1]}"_a')
            if arg[2] is not None:
                f.write(f" = {arg[2]}")
            f.write(", ")
        f.write("py::return_value_policy::automatic_reference);\n")


def parse(name: str, argStr: str) -> ParsedFunc:
    argList = []
    if len(argStr) > 0:
        argStrList: list[str] = []
        openBrackets = 0
        curArg = StringIO()
        for char in argStr:
            if char == "," and openBrackets == 0:
                argStrList.append(curArg.getvalue())
                curArg = StringIO()
                continue
            elif char == "(":
                openBrackets += 1
            elif char == ")":
                openBrackets -= 1
            curArg.write(char)
        temp = curArg.getvalue()
        if len(temp) > 0:
            argStrList.append(temp)

        for x in argStrList:
            if x.find("=") != -1:
                nameAndType, argValue = x.split("=")
                argValue = argValue.strip()
                if argValue in ("__null", "NULL"):
                    argValue = "nullptr"
            else:
                nameAndType = x
                argValue = None
            nameAndType = nameAndType.strip()
            argType, argName = nameAndType.rsplit(" ", maxsplit=1)
            argList.append((argType, argName, argValue))

    return ParsedFunc(name, argList)


def writeFuncFile(
    config: Config,
    header: TextIO,
    headerFilename: str,
    filename: str,
    funcs: list[ParsedFunc]
):
    header.write(f'void init_{config.prefix}_funcs(py::module& m);\n')

    with open(filename, mode='w') as f:
        f.write("// WARNING AUTOGENERATED DO NOT EDIT\n")
        f.write(f'#include "{headerFilename}"\n')
        f.write(f"void init_{config.prefix}_funcs(py::module& m){{\n")
        for func in funcs:
            func.generate(config, f)
        f.write("}\n")
